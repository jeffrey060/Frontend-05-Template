学习笔记
语言
非形式语言: 语法比较松散
形式语言: 语法严格
0型 无限制文法
1型 上下文相关文法
2型 上下文无关文法
3型 正则文法
产生式(BNF)
终结符
非终结符

// 四则运算
1 + 2 * 3

// 终结符
// 1. Number
// 2. + - * /

// 非终结符
// 1. MultiExpression
// 2. AddExpression
结合形式语言
0型 无限制文法
? ::= ?

1型 上下文相关文法
?<A>? ::= ?<B>?

2型 上下文无关文法
<A> ::= ?

3型 正则文法
<A> ::= <A>?

其它产生式
EBNF、ABNF

图灵完备性
命令式
声明式 (函数式编程)
Number
IEEE 754 双精度浮点数

String
面向对象
对象的行为改变状态

能表示的最大数字是多少
最大为 1.11111...(52) * 2 **1023 即为：Number.max_value，但是 Number.min_value 表示 JavaScript 中最小的正数。

能确保精度的最大整数是多少（最大安全数字）
M 部分表示精度的大小，因为 M 部分只有 52byte(如果超过 52 位则会被四舍五入），所以能确保精度的最大整数为 1.1111...(52) * 2 ** 52(=2**53 - 1)，即 Number.MAX_SAFE_INTEGER。

0.1 + 0.2 !== 0.3
<<<<<<< HEAD
如上面介绍的 JavaScript 中 Number 存储机制，只有能被 2 的次幂相加得到的数能（如 6.75 = 2 ** 2 + 2 ** 1 + 2 ** -1 + 2 ** -2 = 110.11 = 1.1011 * 2 ** 2）精确表示，那些不能用二进制精确表示的数，在（M 部分）52 位后会按照遇 1 进 1，遇 0 舍去的原则进行处理，导致精度缺失。所以再来看上式，0.1、0.2、0.3 均无法用二进制精确表示，故在 53 位进行了精度处理，所以最后这个语句共发生了三次精度缺失，分别是 0.1、0.2 、0.3。
.
=======
如上面介绍的 JavaScript 中 Number 存储机制，只有能被 2 的次幂相加得到的数能（如 6.75 = 2 ** 2 + 2 ** 1 + 2 ** -1 + 2 ** -2 = 110.11 = 1.1011 * 2 ** 2）精确表示，那些不能用二进制精确表示的数，在（M 部分）52 位后会按照遇 1 进 1，遇 0 舍去的原则进行处理，导致精度缺失。所以再来看上式，0.1、0.2、0.3 均无法用二进制精确表示，故在 53 位进行了精度处理，所以最后这个语句共发生了三次精度缺失，分别是 0.1、0.2 、0.3。
>>>>>>> 0b902c6a2474415c2e898960bf4106c09b9ec5b1
